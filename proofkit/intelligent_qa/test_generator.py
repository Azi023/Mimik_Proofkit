"""
Intelligent Test Generator

Generates Playwright test scripts for discovered features.
"""

from typing import List, Dict, Any
from pathlib import Path
from datetime import datetime

from .feature_discovery import DiscoveredFeature, FeatureType

from proofkit.utils.logger import logger


class TestGenerator:
    """Generates executable test scripts for discovered features."""

    def __init__(self, features: List[DiscoveredFeature], url: str):
        self.features = features
        self.url = url

    def generate_playwright_tests(self) -> str:
        """Generate a complete Playwright test file."""

        test_code = f'''"""
Auto-generated QA tests for {self.url}
Generated by Mimik ProofKit Intelligent QA
Generated at: {datetime.utcnow().isoformat()}
"""

import pytest
from playwright.sync_api import Page, expect


@pytest.fixture(scope="module")
def page(browser):
    """Create page and navigate to URL."""
    page = browser.new_page()
    page.goto("{self.url}")
    page.wait_for_load_state("networkidle")
    yield page
    page.close()


'''

        # Group features by type
        by_type: Dict[FeatureType, List[DiscoveredFeature]] = {}
        for f in self.features:
            if f.type not in by_type:
                by_type[f.type] = []
            by_type[f.type].append(f)

        # Generate test class for each type
        for feature_type, features in by_type.items():
            test_code += self._generate_test_class(feature_type, features)

        return test_code

    def _generate_test_class(
        self,
        feature_type: FeatureType,
        features: List[DiscoveredFeature]
    ) -> str:
        """Generate test class for a feature type."""

        class_name = f"Test{feature_type.value.replace('_', ' ').title().replace(' ', '')}"

        code = f'''
class {class_name}:
    """Tests for {feature_type.value} features."""

'''

        for feature in features[:5]:  # Limit to 5 per type
            code += self._generate_feature_tests(feature)

        return code

    def _generate_feature_tests(self, feature: DiscoveredFeature) -> str:
        """Generate tests for a single feature."""

        func_name = f"test_{feature.id}_{feature.type.value}"

        code = f'''
    def {func_name}(self, page: Page):
        """
        Feature: {feature.text[:50] if feature.text else feature.type.value}
        Location: {feature.location}
        Expected: {feature.expected_behavior}
        """
'''

        # Generate test based on feature type
        if feature.type == FeatureType.WHATSAPP:
            code += self._generate_whatsapp_test(feature)

        elif feature.type == FeatureType.FORM:
            code += self._generate_form_test(feature)

        elif feature.type == FeatureType.NAVIGATION:
            code += self._generate_navigation_test(feature)

        elif feature.type == FeatureType.ACCORDION:
            code += self._generate_accordion_test(feature)

        elif feature.type == FeatureType.SOCIAL:
            code += self._generate_social_test(feature)

        elif feature.type == FeatureType.BUTTON:
            code += self._generate_button_test(feature)

        elif feature.type == FeatureType.LINK:
            code += self._generate_link_test(feature)

        else:
            code += self._generate_generic_test(feature)

        return code

    def _generate_whatsapp_test(self, feature: DiscoveredFeature) -> str:
        return '''
        # Find WhatsApp button
        whatsapp = page.locator("a[href*='wa.me'], a[href*='whatsapp']").first

        # Verify it exists and is visible
        expect(whatsapp).to_be_visible()

        # Check href format
        href = whatsapp.get_attribute("href")
        assert "wa.me" in href or "whatsapp" in href

        # Should open in new tab
        target = whatsapp.get_attribute("target")
        assert target == "_blank" or target is None  # Opens in same or new
'''

    def _generate_form_test(self, feature: DiscoveredFeature) -> str:
        return '''
        # Find form
        form = page.locator("form").first

        if form.count() > 0:
            expect(form).to_be_visible()

            # Find submit button
            submit_btn = form.locator("button[type='submit'], input[type='submit']").first

            if submit_btn.count() > 0:
                # Try submit empty (should fail validation if required fields)
                submit_btn.click()

                # Wait for potential validation
                page.wait_for_timeout(500)

                # Check for validation message or required field
                required = form.locator("[required]")
                if required.count() > 0:
                    # HTML5 validation should prevent submission
                    pass
'''

    def _generate_navigation_test(self, feature: DiscoveredFeature) -> str:
        return '''
        # Find navigation
        nav = page.locator("nav, [role='navigation']").first

        if nav.count() > 0:
            expect(nav).to_be_visible()

            # Get all links
            links = nav.locator("a")
            link_count = links.count()
            assert link_count > 0, "Navigation should have links"

            # Check all links have href
            for i in range(min(link_count, 10)):
                link = links.nth(i)
                href = link.get_attribute("href")
                assert href is not None, f"Link {i} missing href"
'''

    def _generate_accordion_test(self, feature: DiscoveredFeature) -> str:
        return '''
        # Find accordion
        accordion = page.locator(".accordion, [data-accordion], .faq").first

        if accordion.count() > 0:
            # Find toggle buttons
            toggles = accordion.locator("button, [role='button'], .accordion-header")

            if toggles.count() > 0:
                # Click first toggle
                first_toggle = toggles.first
                first_toggle.click()

                # Content should be visible after click
                page.wait_for_timeout(500)  # Animation
'''

    def _generate_social_test(self, feature: DiscoveredFeature) -> str:
        selector = feature.element if feature.element != "unknown" else "a[href*='facebook'], a[href*='twitter'], a[href*='instagram'], a[href*='linkedin']"
        return f'''
        # Find social link
        social_link = page.locator("{selector}").first

        if social_link.count() > 0:
            # Check href is valid
            href = social_link.get_attribute("href")
            assert href is not None
            assert any(domain in href for domain in ["facebook", "twitter", "instagram", "linkedin", "youtube"])

            # Should open in new tab
            target = social_link.get_attribute("target")
            # Most social links should open in new tab
            # assert target == "_blank"
'''

    def _generate_button_test(self, feature: DiscoveredFeature) -> str:
        selector = feature.element if feature.element != "unknown" else "button"
        return f'''
        # Find button
        button = page.locator("{selector}").first

        if button.count() > 0:
            # Check visibility
            if button.is_visible():
                expect(button).to_be_visible()

                # Check clickable
                expect(button).to_be_enabled()
'''

    def _generate_link_test(self, feature: DiscoveredFeature) -> str:
        return '''
        # Generic link test
        links = page.locator("a[href]")

        if links.count() > 0:
            # Check first few links have valid hrefs
            for i in range(min(links.count(), 5)):
                link = links.nth(i)
                href = link.get_attribute("href")
                # Links should have href
                assert href is not None or href != ""
'''

    def _generate_generic_test(self, feature: DiscoveredFeature) -> str:
        selector = feature.element if feature.element != "unknown" else "*"
        return f'''
        # Generic test for {feature.type.value}
        # Selector: {selector}
        element = page.locator("{selector}").first

        if element.count() > 0:
            # Basic visibility check
            pass  # Element exists
'''

    def generate_pytest_config(self) -> str:
        """Generate pytest configuration."""
        return '''# pytest.ini configuration for generated tests
[pytest]
asyncio_mode = auto
testpaths = .
python_files = test_*.py
python_classes = Test*
python_functions = test_*
'''

    def generate_conftest(self) -> str:
        """Generate conftest.py for pytest fixtures."""
        return '''"""
Pytest configuration and fixtures for generated QA tests.
"""

import pytest
from playwright.sync_api import sync_playwright


@pytest.fixture(scope="session")
def browser():
    """Launch browser for test session."""
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        yield browser
        browser.close()


@pytest.fixture(scope="session")
def browser_context(browser):
    """Create browser context with common settings."""
    context = browser.new_context(
        viewport={"width": 1280, "height": 720},
        user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    )
    yield context
    context.close()
'''

    def save_tests(self, output_dir: Path) -> Dict[str, Path]:
        """
        Save generated tests to files.

        Args:
            output_dir: Directory to save test files

        Returns:
            Dict mapping file type to path
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        files = {}

        # Save test file
        test_file = output_dir / "test_generated_qa.py"
        test_code = self.generate_playwright_tests()
        test_file.write_text(test_code, encoding='utf-8')
        files["tests"] = test_file
        logger.info(f"Tests saved to {test_file}")

        # Save conftest
        conftest_file = output_dir / "conftest.py"
        conftest_file.write_text(self.generate_conftest(), encoding='utf-8')
        files["conftest"] = conftest_file

        # Save summary
        summary = {
            "url": self.url,
            "features_discovered": len(self.features),
            "test_classes_generated": len(set(f.type for f in self.features)),
            "features_by_type": {},
            "generated_at": datetime.utcnow().isoformat(),
        }

        for f in self.features:
            type_key = f.type.value
            if type_key not in summary["features_by_type"]:
                summary["features_by_type"][type_key] = 0
            summary["features_by_type"][type_key] += 1

        import json
        summary_file = output_dir / "qa_summary.json"
        summary_file.write_text(json.dumps(summary, indent=2), encoding='utf-8')
        files["summary"] = summary_file

        return files

    def get_test_count(self) -> int:
        """Get total number of test cases."""
        return sum(len(f.test_cases) for f in self.features)
