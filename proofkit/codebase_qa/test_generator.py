"""
Test Generator for Codebase QA

Generates test scripts for discovered code components.
Uses AI to create intelligent, contextual tests.
"""

import json
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime

from proofkit.utils.logger import logger


class CodebaseTestGenerator:
    """
    Generates test scripts for discovered code components.

    Creates:
    - Unit tests for functions and methods
    - Integration tests for classes
    - API endpoint tests
    - Component interaction tests
    """

    def __init__(self, components: List[Any], root_path: Path):
        """
        Initialize the test generator.

        Args:
            components: List of CodeComponent objects
            root_path: Root path of the codebase
        """
        self.components = components
        self.root_path = root_path

    def generate(self, output_dir: Path) -> Dict[str, Any]:
        """
        Generate tests for all components.

        Args:
            output_dir: Directory to save generated tests

        Returns:
            Dict with generation results
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        results = {
            "test_count": 0,
            "files_generated": [],
            "generated_at": datetime.utcnow().isoformat(),
        }

        # Group components by file
        by_file: Dict[str, List] = {}
        for comp in self.components:
            if comp.file_path not in by_file:
                by_file[comp.file_path] = []
            by_file[comp.file_path].append(comp)

        # Generate tests for each file
        for file_path, comps in by_file.items():
            # Determine test file name
            path = Path(file_path)
            test_filename = f"test_{path.stem}.py"
            test_path = output_dir / test_filename

            # Generate test content
            test_content = self._generate_test_file(file_path, comps)

            if test_content:
                test_path.write_text(test_content, encoding='utf-8')
                results["files_generated"].append(str(test_path))
                results["test_count"] += len(comps)

        # Generate conftest.py
        conftest_path = output_dir / "conftest.py"
        conftest_path.write_text(self._generate_conftest(), encoding='utf-8')
        results["files_generated"].append(str(conftest_path))

        # Generate test summary
        summary_path = output_dir / "test_summary.json"
        summary_path.write_text(json.dumps(results, indent=2), encoding='utf-8')

        logger.info(f"Generated {results['test_count']} tests in {len(results['files_generated'])} files")
        return results

    def _generate_test_file(self, file_path: str, components: List) -> str:
        """Generate test file for a set of components."""
        path = Path(file_path)

        # Determine import path
        module_path = str(path.with_suffix('')).replace('/', '.').replace('\\', '.')

        content = f'''"""
Auto-generated tests for {file_path}
Generated by ProofKit Codebase QA
Generated at: {datetime.utcnow().isoformat()}
"""

import pytest
from unittest.mock import Mock, patch, MagicMock

# TODO: Adjust import path based on your project structure
# from {module_path} import *


'''

        # Group by type
        classes = [c for c in components if c.type == "class"]
        functions = [c for c in components if c.type == "function"]
        methods = [c for c in components if c.type == "method"]

        # Generate class tests
        for cls in classes:
            content += self._generate_class_tests(cls)

        # Generate function tests
        for func in functions:
            content += self._generate_function_tests(func)

        return content

    def _generate_class_tests(self, component) -> str:
        """Generate tests for a class."""
        class_name = component.name

        content = f'''
class Test{class_name}:
    """Tests for {class_name} class."""

    @pytest.fixture
    def instance(self):
        """Create a {class_name} instance for testing."""
        # TODO: Add proper initialization
        # return {class_name}()
        pass

    def test_{class_name.lower()}_instantiation(self, instance):
        """Test that {class_name} can be instantiated."""
        # TODO: Implement
        # assert instance is not None
        pass

'''

        # Add docstring-based tests if available
        if component.docstring:
            content += f'''    def test_{class_name.lower()}_documented_behavior(self, instance):
        """
        Test documented behavior:
        {component.docstring[:200]}
        """
        # TODO: Implement based on docstring
        pass

'''

        return content

    def _generate_function_tests(self, component) -> str:
        """Generate tests for a function."""
        func_name = component.name

        # Clean function name for test method
        test_name = func_name.lower().replace("_", "_")

        content = f'''
class Test{func_name.replace("_", " ").title().replace(" ", "")}Function:
    """Tests for {func_name} function."""

'''

        # Basic test
        content += f'''    def test_{test_name}_returns_expected_type(self):
        """Test that {func_name} returns expected type."""
        # TODO: Implement
        # result = {func_name}()
        # assert isinstance(result, ExpectedType)
        pass

'''

        # Parameter tests
        if component.parameters:
            params_str = ", ".join(component.parameters[:3])
            content += f'''    def test_{test_name}_with_valid_params(self):
        """Test {func_name} with valid parameters: {params_str}."""
        # TODO: Implement
        # result = {func_name}({params_str})
        # assert result is not None
        pass

    def test_{test_name}_with_invalid_params(self):
        """Test {func_name} handles invalid parameters gracefully."""
        # TODO: Implement
        # with pytest.raises(ValueError):
        #     {func_name}(invalid_param)
        pass

'''

        # Edge case tests
        content += f'''    def test_{test_name}_edge_cases(self):
        """Test {func_name} edge cases."""
        # TODO: Implement edge case tests
        # - Empty inputs
        # - None values
        # - Boundary conditions
        pass

'''

        # Docstring-based test
        if component.docstring:
            content += f'''    def test_{test_name}_documented_behavior(self):
        """
        Test documented behavior:
        {component.docstring[:200]}
        """
        # TODO: Implement based on docstring
        pass

'''

        return content

    def _generate_conftest(self) -> str:
        """Generate pytest conftest.py."""
        return '''"""
Pytest configuration for auto-generated tests.
Generated by ProofKit Codebase QA
"""

import pytest
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))


@pytest.fixture(scope="session")
def project_root():
    """Return project root path."""
    return Path(__file__).parent.parent


@pytest.fixture
def sample_data():
    """Provide sample test data."""
    return {
        "string": "test_value",
        "number": 42,
        "list": [1, 2, 3],
        "dict": {"key": "value"},
    }


@pytest.fixture
def mock_response():
    """Create a mock HTTP response."""
    from unittest.mock import Mock

    response = Mock()
    response.status_code = 200
    response.json.return_value = {"status": "ok"}
    return response


# Add custom markers
def pytest_configure(config):
    """Configure custom pytest markers."""
    config.addinivalue_line("markers", "slow: mark test as slow running")
    config.addinivalue_line("markers", "integration: mark test as integration test")
    config.addinivalue_line("markers", "unit: mark test as unit test")
'''

    def generate_with_ai(self, output_dir: Path) -> Dict[str, Any]:
        """
        Generate tests using AI for better quality.

        Args:
            output_dir: Directory to save generated tests

        Returns:
            Dict with generation results
        """
        try:
            from proofkit.narrator.ai_client import get_ai_client

            client = get_ai_client()
            output_dir.mkdir(parents=True, exist_ok=True)

            results = {
                "test_count": 0,
                "files_generated": [],
                "ai_enhanced": True,
                "generated_at": datetime.utcnow().isoformat(),
            }

            # Generate tests for key components
            for comp in self.components[:10]:  # Limit to avoid excessive API calls
                test_code = self._ai_generate_test(client, comp)
                if test_code:
                    test_path = output_dir / f"test_{comp.name.lower()}.py"
                    test_path.write_text(test_code, encoding='utf-8')
                    results["files_generated"].append(str(test_path))
                    results["test_count"] += 1

            return results

        except Exception as e:
            logger.warning(f"AI test generation failed: {e}. Falling back to template-based generation.")
            return self.generate(output_dir)

    def _ai_generate_test(self, client, component) -> Optional[str]:
        """Generate test for a component using AI."""
        try:
            system_prompt = """You are an expert test engineer. Generate comprehensive pytest tests.
Include:
- Happy path tests
- Edge case tests
- Error handling tests
- Mocking where appropriate

Return ONLY valid Python code, no explanations."""

            user_prompt = f"""Generate pytest tests for this component:

Name: {component.name}
Type: {component.type}
File: {component.file_path}
Parameters: {', '.join(component.parameters) if component.parameters else 'None'}
Docstring: {component.docstring or 'None'}

Generate comprehensive tests following pytest best practices."""

            response = client.generate(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                max_tokens=1000,
            )

            # Clean response
            code = response.strip()
            if code.startswith("```python"):
                code = code[9:]
            if code.startswith("```"):
                code = code[3:]
            if code.endswith("```"):
                code = code[:-3]

            return code.strip()

        except Exception as e:
            logger.warning(f"Failed to generate AI test for {component.name}: {e}")
            return None
